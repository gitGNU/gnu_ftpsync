#!/usr/bin/env perl
#
# $Id$
#
# See attached README file for any details, or call
# ftpsync -h
# for quick start.
#
# LICENSE
#
#    FTPSync.pl (ftpsync) is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
################################################################################

#
# Options etc.
#
#print "Starting imports.\n"; # For major problem debugging

use File::Temp qw(tempfile tempdir);
use File::Find;
use File::Basename;
use File::Listing;
use Net::FTP;
use Net::Cmd;
use Net::Netrc;
use strict;
use Getopt::Long;
use URI::Escape;
use File::Path qw(make_path);

# flushing ...
use IO::Handle;
STDOUT->autoflush(1);
STDERR->autoflush(1);

# Option Variables
#print "Defining variables.\n"; # For major problem debugging
# meta
my $returncode=0;
my $configfile=$ENV{"HOME"}."/.ftpsync";
# basics
my $localdir="";
my $remoteURL="";
my $syncdirection="";
my $ftpuser="ftp";
my $ftppasswd="anonymous";
my $ftpserver="localhost";
my $ftpdir="";
my $ftptimeout=120;
my $syncoff=0;
# verbosity
$opt::verbose=2;
my $doverbose=1;
my $dodebug=0;
my $doquiet=0;
my $doinfoonly=0;
my $infotext="";
my $docheckfirst=0;
my $ignoremask = undef;
my $nodelete=0;
my $followsymlinks=0;
my $doflat=0;
my $notimestamping=0;
my $notimestampcheck=0;
my $slowmillis=100;

# Read command line options/parameters
#print "Reading command line options.\n"; # For major problem debugging
my $curopt;
my @cloptions=();
for $curopt (@ARGV) {
  if ($curopt =~ /^cfg=(.*)/) {
    $configfile=$1;
    if (! -r $configfile) { print "Config file does not exist: ".$configfile."\n"; $returncode+=1; }
  } else {
    push @cloptions, $curopt;
  }
}

# Read Config File, if given
my @cfgfoptions=();
if ($configfile ne "") {
  if (-r $configfile) {
    #print "Reading config file.\n"; # For major problem debugging
    open (CONFIGFILE,"<$configfile");
    while (<CONFIGFILE>) {
      $_ =~ s/([ 	\n\r]*$|\.\.|#.*$)//gs;
      if ($_ eq "") { next; }
      if ( ($_ =~ /[^=]+=[^=]+/) || ($_ =~ /^-[a-zA-Z]+$/) ) { push @cfgfoptions, $_; }
    }
    close (CONFIGFILE);
  } # else { print "Config file does not exist.\n"; } # For major problem debugging
} # else { print "No config file to read.\n"; } # For major problem debugging

sub options_hash {
    # Returns a hash of the GetOptions config
    return
	("debug|d|D" => \$opt::debug,
	 "verbose|v" => \@opt::verbose,
	 "version|V" => \$opt::version,
	 "dry-run|dryrun" => \$opt::dryrun,
	 "help|h|H" => \$opt::help,
	 "check|c|C" => \$opt::check,
	 "flat|f|F" => \$opt::flat,
	 "get|g|G" => \$opt::get,
	 "put|p|P" => \$opt::put,
	 "info|i|I" => \$opt::info,
	 "links|l|L" => \$opt::links,
	 "quiet|q|Q" => \$opt::quiet,
	 "move|remove-source-files" => \$opt::move,
	 "notimestampcheck|s|S" => \$opt::notimestampcheck,
	 "notimestamping|t|T" => \$opt::notimestamping,
	 "nodelete|n|N" => \$opt::nodelete,
	 "delete" => \$opt::delete,
	 "cfg=s" => \$opt::cfg,
	 "ftpserver=s" => \$opt::ftpserver,
	 "ftpdir=s" => \$opt::ftpdir,
	 "ftpuser=s" => \$opt::ftpuser,
	 "ftppasswd|ftppass|ftppassword=s" => \$opt::ftppasswd,
	 "passiv|passive" => \$opt::passive,
	 "localdir=s" => \$opt::localdir,
	 "ignoremask=s" => \$opt::ignoremask,
	 "size-only|size|sizeonly" => \$opt::sizeonly,
	 "slowmillis=i" => \$opt::slowmillis,
	 "timeoffset=i" => \$opt::timeoffset,
	 "timeout=i" => \$opt::timeout,
	 # rsync compatibilty
	 "exclude" => \$opt::exclude,
	);
}

sub get_options_from_array {
    # Run GetOptions on @array
    # Returns:
    #   true if parsing worked
    #   false if parsing failed
    #   @array is changed
    my $array_ref = shift;
    # A bit of shuffling of @ARGV needed as GetOptionsFromArray is not
    # supported everywhere
    my @save_argv;
    my $this_is_ARGV = (\@::ARGV == $array_ref);
    if(not $this_is_ARGV) {
	@save_argv = @::ARGV;
	@::ARGV = @{$array_ref};
    }
    my $retval = GetOptions(options_hash());
    if(not $this_is_ARGV) {
	@{$array_ref} = @::ARGV;
	@::ARGV = @save_argv;
    }
    return $retval;
}

sub parse_options {
    Getopt::Long::Configure("bundling","require_order");
    get_options_from_array(\@ARGV) || die_usage();
    my @cfgoptions;
    if(defined $opt::cfg) {
	open(IN,"<",$opt::cfg) || die_usage();
	@cfgoptions = <IN>;
	close IN;
	get_options_from_array(\@cfgoptions) || die_usage();
    }
    if($opt::check) { $docheckfirst=1; }
    if($opt::debug) { $dodebug=1; $doverbose=3; $doquiet=0; $opt::verbose = 3; }
    if($opt::flat) { $doflat=1; }
    if($opt::get) { $syncdirection="get"; }
    if($opt::help) { print_syntax(); exit 0; }
    if($opt::info) { $doinfoonly=1; }
    if($opt::links) { $followsymlinks=1; }
    if($opt::put) { $syncdirection="put"; }
    if($opt::quiet) { $dodebug=0; $doverbose=0; $doquiet=1; $opt::verbose = 0; }
    if($opt::notimestampcheck) { $notimestampcheck=1; }
    if($opt::notimestamping) { $notimestamping=1; }
    if(@opt::verbose)  { $doverbose=@opt::verbose; $opt::verbose=@opt::verbose; }
    if($opt::nodelete)  { $nodelete=1; }

    for my $arg (@ARGV) {
	if($arg =~ /^ftp:\/\/(([^@\/\\\:]+)(:([^@\/\\\:]+))?@)?([a-zA-Z01-9\.\-]+)(\/.*)?/) {
	    $remoteURL = $arg;	    
	    parse_remote_url();
	    $syncdirection ||= "get";
	}
    }
    if(defined $opt::ftpdir) { 
	$ftpdir = $opt::ftpdir;
	if($ftpdir ne "/") { $ftpdir=~s/\/$//; }
	$syncdirection ||= "get";
    }
    if(defined $opt::ftppasswd) {
	$ftppasswd = $opt::ftppasswd;
	$syncdirection ||= "get";
    }
    if(defined $opt::ftpserver) {
	$ftpserver = $opt::ftpserver;
	$syncdirection ||= "get";
    }
    if(defined $opt::ftpuser) {
	$ftpuser = $opt::ftpuser;
	$syncdirection ||= "get";
    }
    if(defined $opt::localdir) {
	$localdir = $opt::localdir;
	$localdir=~s/\/$//;
	$syncdirection ||= "put";
    }
    if($opt::timeout) {
	$ftptimeout = $opt::timeout;
    }
    if(defined $opt::ignoremask) {
	$ignoremask = $opt::ignoremask;
    }
    if(defined $opt::timeoffset) {
	$syncoff = $opt::timeoffset;
    }
    if(defined $opt::slowmillis) {
	$slowmillis = $opt::slowmillis;
    }
    if ($localdir eq "") {
	$localdir = shift @ARGV;
	$syncdirection ||= "put";
    } else {
	error("Unknown parameter: \"".@ARGV."\"\n"); $returncode+=1
    }
}

sub die_usage {
    print STDERR
	qq(Usage:\n);
    exit(1);
}

parse_options();
gnu_main();
exit(0);

sub gnu_main {
    my @src_urls;
    my $dst_url = fill_in_ftpurl(pop @ARGV);
    push(@src_urls,fill_in_ftpurl($localdir,@ARGV));
    
    my %src_tree = buildtree(@src_urls);
    my %dst_tree = buildtree($dst_url);
    my @files_to_add = sort(missing(\%src_tree,\%dst_tree));
    my @files_to_delete = sort(missing(\%dst_tree,\%src_tree));
    my @files_to_update = sort(changed(\%src_tree,\%dst_tree));
    my @src_files_to_delete = $opt::move ? sort(keys %src_tree) : ();

    logger("","Files to add: ".($#files_to_add+1)."\n",
	   "Files to add: @files_to_add\n");
    if($opt::delete) {
	logger("","Files to delete: ".($#files_to_delete+1)."\n",
	       "Files to delete: @files_to_delete\n");
    }
    logger("","Files to update: ".($#files_to_update+1)."\n",
	   "Files to update: @files_to_update\n");
    logger("","Source files to delete: ".($#src_files_to_delete+1)."\n",
	   "Source files to delete: @src_files_to_delete\n");
    
    if($opt::delete) {
	# Delete before copy to avoid problems if a src dir is a file on dst
	delete_files(\%dst_tree,$dst_url,@files_to_delete,@files_to_update);
    }

    copy(\%src_tree,$dst_url,@files_to_add,@files_to_update);

    if($opt::move) {
	for my $src_url (@src_urls) {
	    delete_files(\%src_tree,$src_url,@src_files_to_delete);
	}
    }
    print("FINISHED\n");
    exit(0);
}

# .netrc support 
if ( ($ftpserver ne "") and ($ftppasswd eq "anonymous") ) {
  if ($ftpuser eq "ftp") {
    my $netrcdata = Net::Netrc->lookup($ftpserver);
    if ( defined $netrcdata ) {
      $ftpuser = $netrcdata->login;
      $ftppasswd = $netrcdata->password;
    }
  } else { 
    my $netrcdata = Net::Netrc->lookup($ftpserver,$ftpuser);
    if ( defined $netrcdata ) {
      $ftppasswd = $netrcdata->password;
    }
  }
}

#if($ftpuser   eq "?") { print "User: ";     $ftpuser=<STDIN>;   chomp($ftpuser);   }
#if($ftppasswd eq "?") { print "Password: "; $ftppasswd=<STDIN>; chomp($ftppasswd); }

if ($dodebug) { print_options(); }
# check options
if (not -e $localdir){ 
    error("Local directory does not exist: ".$localdir."\n"); $returncode+=1;
}
if ($ftpserver eq "") { error("No FTP server given.\n"); $returncode+=1; }
# $ftpdir is allowed to be empty
if ($ftpuser   eq "") { error("No FTP user given.\n"); $returncode+=1; }
if ($ftppasswd eq "") { error("No FTP password given.\n"); $returncode+=1; }
if ($returncode > 0) { die "Aborting due to missing or wrong options! Call ftpsync -? for more information.\n";  }

# Find out if ftp server is online & accessible
my $ftpc = connection();

logger("\nDetermine s offset.\n");
if (($notimestamping+$notimestampcheck) lt 2 && $syncdirection eq "put" && $syncoff == 0) 
{ clocksync($ftpc); }

#  local & remote tree vars
#chdir $localdir;
my $ldl=length($localdir) + 1;
my %localfiledates=();
my %localfilesizes=();
my %localdirs=();
my %locallinks=();

my %remotefilesizes=();
my %remotefiledates=();
my %remotedirs=();
my %remotelinks=();
my $curremotesubdir="";

# Build local & remote tree

logger("\nBuilding local file tree.\n");
buildlocaltree();

logger("\nBuilding remote file tree.\n");

# Prepend connection time out while file reading takes
# longer than the remote ftp time out
# - 421 Connection timed out.
# - code=421 or CMD_REJECT=4
if (!$ftpc->pwd()) {
    #print "Message: (".$ftpc->code."/".$ftpc->status.") ".$ftpc->message; exit 0;
    if ($ftpc->code == 421 or $ftpc->status eq CMD_REJECT) {
        logger("\nReconnect to server.\n");
        $ftpc = connection();
    }
}
buildremotetree();

listremotedirs();

# Work ...
if ($doinfoonly) { $docheckfirst=0; }
if ($docheckfirst)
{ print "Simulating synchronization.\n";
  $doinfoonly=1;
  dosync();
  $doinfoonly=0;
  print "\nOK to really update files? (y/n) [n] ";
  my $yn=<STDIN>;
  if ($yn =~ /^y/i)
  { print "OK, going to do it.\n";
  }
  else
  { print "OK, exiting without actions.\n";
    exit 1;
  }
}
if ($doinfoonly) {
    logger("\nSimulating synchronization.\n");
} else {
    logger("\nStarting synchronization.\n");
}
dosync();

logger("Done.\n");

logger("Quitting FTP connection.\n");
$ftpc->quit();

exit 0;


#
# Subs
#

sub copy {
    my $src_tree_ref = shift;
    my $dst_url = shift;
    my @files = @_;
    my %src = %$src_tree_ref;

    logger("","Copying\n");
    for my $file (sort @files) {
	if(defined $src{$file}{'connection'}) {
	    # Src file is remote
	    if($Global::ftpconnections{$dst_url}) {
		# Dst is remote
		copy_remote_remote($src{$file}{'connection'},$file,$dst_url);
	    } else {
		# Dst is local
		copy_remote_local($src{$file}{'connection'},$file,$dst_url);
	    }
	} else {
	    # Src file is local
	    if($Global::ftpconnections{$dst_url}) {
		# Dst is remote
		copy_local_remote($file,$dst_url,%src);
	    } else {
		# Dst is local
		copy_local_local($file,$dst_url);
	    }
	}
    }
    logger("","\n");

    sub copy_local_local {
	die("Not implemented");
    }
    
    sub copy_local_remote {
	my $filepath = shift;
	my $dst_url = shift;
	my $path = (parse_url($dst_url))[5];
	if($path =~ m:^//:) {
	    # ftp://user@host//path => /path
	    $path =~ s:^//:/:;
	} elsif($path =~ m:^/:) {
	    # ftp://user@host/path => ./path
	    $path =~ s:^:.:;
	}
	my %src = @_;
	my $ftpc = $Global::ftpconnections{$dst_url};
	my $file = $src{$filepath};
	# Make subdirs if needed
	$opt::dryrun or ftpmkdirhier($ftpc,$path);
	my $would = $opt::dryrun ? "Would " : "";
	if($file->{'size'} == -1) {
	    my $cpath = clean_dir_name($path);
	    logger("",":",$would."Make dir $filepath\n",$would."Make dir $dst_url$filepath\n");
	    $opt::dryrun or ftpmkdir($ftpc,$cpath.$filepath);
	} else {
	    my $cpath = clean_dir_name($path);
	    logger("",".",$would."Copy $file->{'abspath'} to $cpath$filepath\n",
		   $would."Copy $file->{'abspath'} to $dst_url/$filepath\n");
	    if(not $opt::dryrun) {
		ftpsleep();
		$ftpc->delete($cpath.$filepath);
		if(not $ftpc->put($file->{'abspath'},$cpath.$filepath)) {
		    warning("Cannot write $cpath$filepath\n");
		}
	    }
	}
    }

    sub copy_remote_local {
	my $ftpc = shift;
	my $filepath = shift;
	my $path = shift;
#	my $ftpc = $Global::ftpconnections{$src_url};
	my $file = $src{$filepath};
	# Make subdirs if needed
	make_path($path);
	if($file->{'size'} == -1) {
	    logger("",":","Make dir $filepath\n","Make dir $path/$filepath\n");
	    make_path($path."/".$filepath);
	} else {
	    my $cpath = clean_dir_name($path);
	    logger("",".","Copy $file->{'abspath'} to $cpath$filepath\n","Copy $file->{'abspath'} to $path/$filepath\n");
	    ftpsleep();
	    if(not $ftpc->get($file->{'abspath'},$cpath.$filepath)) {
		die "Cannot write $cpath$filepath";
	    }
	}
    }
    
    sub copy_remote_remote {
	die("Not implemented");
    }
}

sub delete_files {
    my $tree_ref = shift;
    my $url = shift;
    my @files = @_;

    logger("","Deleting\n","Deleting\n","Deleting from $url\n");
    if($Global::ftpconnections{$url}) {
	# Remote url
	delete_remote($Global::ftpconnections{$url},$url,$tree_ref,@files);
    } else {
	delete_local($tree_ref,@files);
    }
    logger("","\n");

    sub delete_remote {
	my $ftpc = shift;
	my $url = shift;
	my $tree_ref = shift;
	my @files = @_;
	my %tree = %$tree_ref;
	for my $f (sort { length($b) <=> length($a) } @files) {
	    # Sort by length to make sure files are deleted before dirs
	    my $would = $opt::dryrun ? "Would " : "";
	    if($tree{$f}{'size'} == -1) {
		# This is a dir
		logger("",":",$would."Rmdir:  $tree{$f}{'abspath'}\n",
		       $would."Rmdir:  $url / $f = $tree{$f}{'abspath'}\n");
		$opt::dryrun or $ftpc->rmdir($tree{$f}{'abspath'});
	    } else {
		logger("",".",$would."Delete: $tree{$f}{'abspath'}\n",
		       $would."Delete: $url / $f = $tree{$f}{'abspath'}\n");
		$opt::dryrun or $ftpc->delete($tree{$f}{'abspath'});
	    }
	}
    }

    sub delete_local {
	my $tree_ref = shift;
	my %tree = %$tree_ref;	
	my @files = @_;
	for my $f (sort { length($b) <=> length($a) } @files) {
	    # Sort by length to make sure files are deleted before dirs
	    my $would = $opt::dryrun ? "Would " : "";
	    if($tree{$f}{'size'} == -1) {
		# This is a dir
		logger("",":",$would."Rmdir:  $tree{$f}{'abspath'}\n",
		       $would."Rmdir:  $url / $f = $tree{$f}{'abspath'}\n");
		$opt::dryrun or rmdir($tree{$f}{'abspath'});
	    } else {
		logger("",".",$would."Delete: $tree{$f}{'abspath'}\n",
		       $would."Delete: $url / $f = $tree{$f}{'abspath'}\n");
		$opt::dryrun or unlink($tree{$f}{'abspath'});
	    }
	}
    }
}

sub ftpmkdirhier {
    my $ftpc = shift;
    my $dir = shift;
    my @a = split "/", $dir;
    my @dir;
    while(@a) {
	push @dir, shift @a;
	ftpmkdir($ftpc,join("/",@dir));
    }
}

sub ftpmkdir {
    my $ftpc = shift;
    my $dir = shift;
    if($FTPMKDIR::already_done{$dir}++) {
	# skip
    } else {
	ftpsleep();
	if(not $ftpc->mkdir($dir)) {
	    # Ignore
	}
	logger("","","","mkdir $dir\n");
    }
}

sub ftpsleep {
    # Sleep for 0.1 sec
    usleep($opt::slowmillis || 100);
}

sub fill_in_ftpurl {
    # Fill in ftpurl with missing information
    # ftp://?:?@ => Ask for user, pass
    # If .netrc exists, use that for missing fields
    my @urls = @_;
    for my $url (@urls) {
	my ($scheme,$user,$pass,$host,$port,$dir) = parse_url($url);
	if($scheme =~ /^ftps?$/i) {
	    if($user eq "?") {
		print "User: ";
		$user=<STDIN>;
		chomp($user);
	    }
	    if($pass eq "?") {
		print "Password: ";
		$pass=<STDIN>;
		chomp($pass);
	    }
	    if($host eq "?") {
		print "Host: ";
		$host=<STDIN>;
		chomp($host);
	    }
	    if($port eq "?") {
		print "Port: ";
		$port=<STDIN>;
		chomp($port);
	    }
	    if($dir eq "?") {
		print "Dir: ";
		$dir=<STDIN>;
		chomp($dir);
	    }
	    # TODO read from netrc
	    if(not defined $user) {
	    }
	    if(not defined $pass) {
	    }
	    if(not defined $host) {
	    }
	    if(not defined $port) {
	    }
	    if(not defined $dir) {
	    }
	    
	    $url = $scheme . "://" . uri_escape($user) . ":" . uri_escape($pass) . '@' .
		$host . ($port ? ":" . $port : "") . "/" . uri_escape($dir);
	}
    }
    return(wantarray() ? @urls : pop @urls);
}

sub parse_url {
    my $url = shift;
    if($url =~ m!(ftp|ftps|sftp):// # Scheme ($1)
       (?:
	([^:@/][^:@]*|) # Username ($2)
	(?:
	 :([^@]*) # Password ($3)
	)?
	@)?
       ([^:/]*)? # Hostname ($4)
       (?:
	:
	([^/]*)? # Port ($5)
       )?
       (?:
	/
	(.*)? # Dir ($6)
       )?
       $
       !ix) {
	my ($scheme,$user,$pass,$host,$port,$dir) = uri_unescape($1,$2,$3,$4,$5,$6);
	return ($scheme,$user,$pass,$host,$port,$dir);
    } else {
	if($url =~ m{://}) {
	    error("$url is not an URL\n");
	} else {
	    # Not ftpurl - return as single string
	    return $url;
	}
    }
}

sub ftpconnect {
    # Return ftp connection object
    my $url = shift;
    if(not defined $Global::ftpconnections{$url}) {
	my($scheme,$user,$pass,$host,$port,$dir) = parse_url($url);
	my $doftpdebug=($opt::verbose > 4);
	my $passive;
	if(defined $opt::passive) {
	    $passive = $opt::passive;
	} else {
	    $passive = autodetect_passive($user,$pass,$host,$doftpdebug);
	}
	my $ftpc = Net::FTP->new($host, Debug => $doftpdebug,
				 Timeout => ($opt::timeout || 120), 
				 Passive => $passive)
	    || die "Could not connect to $host\n";
	logger("","","Logging in as $user.\n","Logging in as $user with password $pass.\n");
	$ftpc->login($user,$pass) || die "Could not login to $host as $user\n";
	$ftpc->binary()
	    or die "Cannot set binary mode ", $ftpc->message;
	$Global::ftpconnections{$url} = $ftpc;
	$Global::timeoffset{$url} = timeoffset($url);
    } 
    return $Global::ftpconnections{$url};
}

sub autodetect_passive {
    my ($user,$pass,$host,$doftpdebug) = @_;
    my $passive_pid;
    my $active_pid;
    $SIG{CHLD} = 'IGNORE';
    if(not $passive_pid = fork()) {
	my $ftpc = Net::FTP->new($host, Debug => $doftpdebug,
				 Timeout => ($opt::timeout || 120), 
				 Passive => 1)
	    || die "Could not connect to $host\n";
	$ftpc->login($user,$pass) || die "Could not login to $host as $user\n";
	$ftpc->dir(".");
	exit(0);
    }
    if(not $active_pid = fork()) {
	my $ftpc = Net::FTP->new($host, Debug => $doftpdebug,
				 Timeout => ($opt::timeout || 120), 
				 Passive => 0)
	    || die "Could not connect to $host\n";
	$ftpc->login($user,$pass) || die "Could not login to $host as $user\n";
	$ftpc->dir(".");
	sleep(1);
	exit(0);
    }
    my $timeout = ($opt::timeout || 120)*10;
    my $auto_passive;
    logger("","","Detecting if passive needed");
    while($timeout--) {
	if(not kill 0 => $active_pid) {
	    # $active_pid finished
	    $auto_passive = 0;
	    last;
	}
	if(not kill 0 => $passive_pid) {
	    # $passive_pid finished
	    $auto_passive = 1;
	    last;
	}
	usleep(100);
	logger("","",".");
    }
    logger("","",$auto_passive ? " Passive\n" : " Active\n");
    return $auto_passive;
}

sub timeoffset {
    my $url = shift;
    my $ftpc = ftpconnect($url);
    my($scheme,$user,$pass,$host,$port,$dir) = parse_url($url);
    my ($outfh, $localfile) = ::tempfile();
    my ($basename) = basename($localfile);
    my $remote_file;
    if(not -z $localfile) {
	die "File $localfile for time sync must be empty.";
    }
    if(not $ftpc->put($localfile)) {
	if(not $ftpc->put($localfile,"$dir/$basename")) {
	    logger("Cannot send timesync file $localfile. Assuming no time difference.\n",
		   "Cannot send timesync file $localfile. Assuming no time difference.\n",
		   "Cannot send timesync file $localfile. Assuming no time difference.\n",
		   "Cannot send timesync file $url/$basename. Assuming no time difference.\n");
	    return 0;
	} else {
	    $remote_file = "$dir/$basename";
	}
    } else {
	$remote_file = $basename;
    }
    logger("","","Sync file $localfile => $remote_file\n");
    my $now_here1 = (lstat($localfile))[9];
    unlink($localfile);
    my $now_there;
    my @rfl = eval { $ftpc->dir($remote_file) };
    for my $curlsline (parse_dir(\@rfl)) {
	my ($file,$type,$size,$date,$mode) = @$curlsline;
	logger("","","","Mod:".$date." Size:".$size."\t".$file."\n");
	$now_there = $date;
    }
    if(not $now_there) {
	logger("Cannot get mod time of $remote_file. Assuming no time difference.\n",
	       "Cannot get mod time of $remote_file. Assuming no time difference.\n",
	       "Cannot get mod time of $remote_file. Assuming no time difference.\n",
	       "Cannot get mod time of $url/$basename. Assuming no time difference.\n");
	return 0;
    }
    my $now_here2 = time();
    $ftpc->delete($remote_file);
    logger("","","Localtime before $now_here1, Remote $now_there, after $now_here2\n");
    
    if ($now_here2 < $now_there) {
	# remote is in the future
	$syncoff = ($now_there - $now_here1);
	$syncoff -= $syncoff % 60;
	$syncoff = 0-$syncoff;
    } else {
	# remote is the past # or equal
	$syncoff = ($now_here2 - $now_there);
	$syncoff -= $syncoff % 60;
    }
    
    my $hrs = int(abs($syncoff)/3600);
    my $mins = int(abs($syncoff)/60) - $hrs*60;
    my $secs = abs($syncoff) - $hrs*3600 - $mins*60;
    logger("","",sprintf("Clock sync offset: %dh%02dm%02ds\n", $hrs, $mins, $secs));
    return $syncoff;
}

sub changed {
    # Determine if a file is changed:
    #   * size mismatch
    #   * dst_date < src_date
    #
    # Input:
    #   $src_tree_ref: Reference to %src_tree
    #   $dst_tree_ref: Reference to %dst_tree
    #
    # Output:
    #   list of files changed in %dst_tree
    #   files that are missing are ignored
    my ($src_tree_ref,$dst_tree_ref) = @_;
    my %src = %$src_tree_ref;
    my %dst = %$dst_tree_ref;
    my @common = grep { defined $dst{$_} } keys %src;
    my @changed;
    for my $file (@common) {
	if($src{$file}{'size'} == $dst{$file}{'size'}
	   and
	   ($opt::sizeonly or
	    $src{$file}{'date'} <= $dst{$file}{'date'})) {
	    # This is a file with:
	    #   size = size
	    #   --size-only or date <= date
	    # =>
	    # Not changed
	    next;
	}
	if($src{$file}{'size'} == -1 and $dst{$file}{'size'} == -1) {
	    # This is a dir that both have - ignore date
	    # TODO Can we sync mdate?
	    next;
	}
	if(not $opt::delete) {
	    # If we are not allowed to delete the mismatching filetypes
	    # we should fail on changed filetype
	    if($src{$file}{'size'} == -1 and $dst{$file}{'size'} != -1) {
		# A src file is a dir in dst
		error("$file is a dir on source but a file on destination.\n");
	    }
	    if($src{$file}{'size'} != -1 and $dst{$file}{'size'} == -1) {
		# A src dir is a file in dst
		error("$file is a file on source but a dir on destination.\n");
	    }
	}
	if($src{$file}{'size'} != $dst{$file}{'size'}
	   or
	   $src{$file}{'date'} >= $dst{$file}{'date'}) {
	    logger("","","Changed ".$src{$file}{'size'}."!=".$dst{$file}{'size'}.
		   " or ".$src{$file}{'date'}.">=".$dst{$file}{'date'}." $file\n");
	    push @changed, $file;
	    next;
	}
	die_bug("changed: $file");
    }
    return @changed;
}

sub missing {
    # Input:
    #   $src_tree_ref: Reference to %src_tree
    #   $dst_tree_ref: Reference to %dst_tree
    # Output:
    #   list of files missing in %dst_tree
    my ($src_tree_ref,$dst_tree_ref) = @_;
    my %src = %$src_tree_ref;
    my %dst = %$dst_tree_ref;
    my @missing = grep { not defined $dst{$_} } keys %src;
    return @missing;
}

sub buildtree {
    # Build data structure for URLs
    # Returns:
    #   filename is relative to URL
    #   %tree{filename}{'date'}=$modification_date;
    #   %tree{filename}{'size'}=$size;
    #   %tree{filename}{'link'}=$filename;
    #   %tree{filename}{'parentdir'}=dirname($filename);
    #   %tree{filename}{'abspath'}=path from url+$filename
    my @urls = @_;
    my %tree=();
    # For speed first put the full tree in an array before merging
    my @tree_arr = ();
    for my $url (@urls) {
	my ($scheme,$user,$pass,$host,$port,$dir) = parse_url($url);
	if($scheme =~ m{^s?ftps?$}i) {
	    my $url_no_pass = $scheme."://".$user.'@'.$host."/".$dir;
	    logger("","Building remote tree $url_no_pass\n","Building remote tree $url_no_pass\n","Building remote tree of $url\n");
	    push(@tree_arr, remote_tree($url));
	    logger("","\n");
	} else {
	    # Assume local if not starting with ftps?://
	    # file:///foo => /foo
	    $url =~ s{^file://}{}; 
	    logger("","Building local tree of $url\n");
	    push(@tree_arr, local_tree($url));
	    logger("","\n");
	}
    }
    %tree = @tree_arr;
    return %tree;

    sub remote_tree {
	my $url = shift;
	my $ftpc = ftpconnect($url);
	my $path = (parse_url($url))[5];

	if($path =~ m:^//:) {
	    # ftp://user@host//path => /path
	    $path =~ s:^//:/:;
	} elsif($path =~ m:^/:) {
	    # ftp://user@host/path => ./path
	    $path =~ s:^:.:;
	}
	# Single file not implemented => assume dir
	#if(-d $path) {
	    # Dir
	    my %tree = remote_tree_dir($ftpc,"",$path,$url);
	    return %tree;
	#} else {
	    # Single file
	#    return remote_tree_file($path);
	#}

	sub remote_tree_dir {
	    my ($ftpc,$dir,$abs,$url) = @_;
	    logger("",":","Dir: ".$dir." in $abs\n");
	    my %tree = ();
	    my @tree_arr;

	    ftpsleep();
	    my $ftpdir;
	    if($dir eq "") {
		$ftpdir = $abs;
	    } elsif($abs eq "") {
		$ftpdir = $dir;
	    } else {
		$ftpdir = $abs."/".$dir;
	    }
	    my @rfl = eval { $ftpc->dir($ftpdir) };
#	    my %monthtonr;
#	    @monthtonr{qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec)} = 1..12;
	    for my $curlsline (parse_dir(\@rfl)) {
		my ($f,$type,$size,$date,$mode) = @$curlsline;
		my $file = clean_dir_name($dir).$f;
		my $abspath = clean_dir_name($abs).$file;
		if($type eq "d") {
		    if($file =~ /\/\.\.?$/ or $opt::flat) {
			# Ignore . and .. and subdirs if --flat
		    } else {
			push(@tree_arr, remote_tree_dir($ftpc,$file,$abs,$url));
			# Mark directories by setting size to -1
			$tree{$file}{'size'} = -1;
		    }
		} else {
		    $tree{$file}{'size'} = $size;
		}
		$tree{$file}{'date'} = $date + $Global::timeoffset{$url};
		$tree{$file}{'abspath'} = $abspath;
		$tree{$file}{'connection'} = $ftpc;
		$tree{$file}{'parentdir'} = $dir;
		logger("",".","Mod:".$tree{$file}{'date'}." Size:".$tree{$file}{'size'}."\t".$file."\n");
	    }
	    %tree = (@tree_arr,%tree);
	    return %tree;
	}

	sub remote_tree_file {
	    # Not used
	}
    }

    sub local_tree {
	my $path = shift;
	my %tree;
	my $prefix = $path;
	if(not -e $path) {
	    # Path does not exist => return empty
	    return %tree
	}
	my %t2;
	if(-d $path) {
	    # Dir
	    $path = clean_dir_name($path);
	    $path =~ s{/$}{};
	    %t2 = local_tree_dir($path);
	} else {
	    # $path is a file. $prefix = dirname($prefix)
	    $prefix = dirname($prefix);
	    %t2 = local_tree_file($path)
	}
	# remove the prefix to get relative paths
	while(my($k,$v) = each(%t2)) {
	    if($k eq $prefix) {
		# Skip the prefix dir
		next;
	    }
	    $k =~ s:^$prefix/::;
	    $tree{$k} = $v;
	    $tree{$k}{'parentdir'} =~ s:^$prefix/::;
	}
	return %tree;

	sub local_tree_dir {
	    my $dir = shift;
	    logger("",":","Dir: ".$dir."\n");
	    my %tree = ();
	    # For speed first put the full tree in an array before merging
	    my @tree_arr = ();
	    push(@tree_arr, local_tree_file($dir));
	    opendir(my $dh,$dir) || die;
	    my @files_in_dir = map { $dir."/".$_ } readdir($dh);
	    for my $file (@files_in_dir) {
		if($opt::exclude) {
		    $file =~ /$opt::exclude/o and next;
		}
		if(-d $file) {
		    if($file =~ /(^|\/)\.\.?$/ or $opt::flat) {
			# Ignore . and .. and subdirs if --flat
		    } else {
			push(@tree_arr, local_tree_dir($file));
		    }
		} else {
		    push(@tree_arr, local_tree_file($file));
		}
	    }
	    # Merge trees
	    %tree = @tree_arr;
	    return %tree;
	}

	sub local_tree_file {
	    my $file = shift;
	    my %tree;
	    my $dir = $file;
	    $dir =~ s:/?[^/]+$::;
	    if($dir eq "") {
		$dir = ".";
	    }
	    my @stat = lstat($file);
	    if(-d $file) {
		# Mark directories by setting size to -1
		$tree{$file}{'size'} = -1;
	    } else {
		$tree{$file}{'size'} = $stat[7];
	    }
	    $tree{$file}{'date'} = $stat[9];
	    $tree{$file}{'abspath'} = $file;
	    $tree{$file}{'parentdir'} = $dir;
	    logger("",".","Mod:".$tree{$file}{'date'}." Size:".$tree{$file}{'size'}."\t".$file."\n");
	    return %tree;
	}
    }
    
    sub clean_dir_name {
	my $dir = shift;
	# Returns:
	#   dir/ or ""

	# foo/bar/../ => foo/
	while($dir =~ s:[^/]+/\.\.(/|$ )::x) {}
	# ./foo => foo
	# bar/./foo => bar/foo
	while($dir =~ s:(^|[^/]+/)\./::) {}
	# // => /
	while($dir =~ s://:/:) {}
	if($dir eq "" or $dir eq ".") {
	    return "";
	} else {
	    return $dir."/";
	}
    }
}

###

sub buildlocaltree() {
  if ($doflat) {
    chdir $localdir;
    my @globbed=glob("{*,.*}");
    foreach my $curglobbed (@globbed) {
      next if (! -f $curglobbed);
      my @curfilestat=lstat $curglobbed;
      my $curfilesize=@curfilestat[7];
      my $curfilemdt=@curfilestat[9];
      logger("",".","File: ".$curglobbed."\n"."Modified ".$curfilemdt."\nSize ".$curfilesize." bytes\n");
      my $relfilename=$curglobbed;
      $localfiledates{$relfilename}=$curfilemdt;
      $localfilesizes{$relfilename}=$curfilesize;
    }
  } else {
    find ({wanted=>\&noticelocalfile,follow_fast => $followsymlinks }, $localdir."/");
  }
  sub noticelocalfile {
    my $relfilename=substr($File::Find::name,$ldl);
    if (length($relfilename) == 0) { return; }
    if ($ignoremask ne "")
      {
        if ($relfilename =~ /$ignoremask/ ) {
	    logger("","Ignoring ".$relfilename." which matches ".$ignoremask."\n");
	    return;
        }
      }
    if (-d $_) {
      logger("",":","Directory: ".$File::Find::name."\n");
      $localdirs{$relfilename}="$relfilename";
    }
    elsif (-f $_) {
      #my @curfilestat=lstat $File::Find::name;
      my @curfilestat=lstat $_;
      my $curfilesize=@curfilestat[7];
      my $curfilemdt=@curfilestat[9];
      logger("",".","File: ".$File::Find::name."\n"."Modified ".$curfilemdt."\nSize ".$curfilesize." bytes\n");
      $localfiledates{$relfilename}=$curfilemdt;
      $localfilesizes{$relfilename}=$curfilesize;
    }
    elsif (-l $_) {
      logger("",",","Link: ".$File::Find::name."\n");
      $locallinks{$relfilename}="$relfilename";
    } else {
      logger("Ignoring file of unknown type: ".$File::Find::name."\n");
    }
  }
  logger("","","Local dirs (relative to ".$localdir."/):\n");
  my $curlocaldir="";
  foreach $curlocaldir (keys(%localdirs)) {
      logger("","",$curlocaldir."/\n");
      logger("","","Local files (relative to ".$localdir."/):\n");
      my $curlocalfile="";
      foreach $curlocalfile (keys(%localfiledates)) {
	  logger("","",$curlocalfile."\n");
      }
  }
}


sub buildremotetree() {
  my @currecursedirs=();
  #$ftpc->ls()
  #  or die $ftpc->message . "\nCannot ls remote dir " . $ftpc->pwd();
  my @rfl = $ftpc->dir('-a');
  # or @rfl=(); # we have to survive empty remote directories !!!
  my $currf="";
  my $curyear = (gmtime(time))[5] + 1900;
  my %monthtonr=();
  $monthtonr{"Jan"}=1; $monthtonr{"Feb"}=2; $monthtonr{"Mar"}=3; $monthtonr{"Apr"}=4; $monthtonr{"May"}=5; $monthtonr{"Jun"}=6;
  $monthtonr{"Jul"}=7; $monthtonr{"Aug"}=8; $monthtonr{"Sep"}=9; $monthtonr{"Oct"}=10; $monthtonr{"Nov"}=11; $monthtonr{"Dec"}=12;
  logger("","","Remote pwd is ".$ftpc->pwd()."\nDIRing.\n");
  my $curlsline;
  foreach $curlsline (parse_dir(\@rfl)) {
    my ($cfname,$cftype,$cfsize,$cftime,$mode)=@$curlsline;
    if ( $cftype ) {
      if ($cfname eq ".") { next; }
      if ($cfname eq "..") { next; }
      if ($ignoremask ne "")
        {
	  my $testpath;
          if ($curremotesubdir eq "") { $testpath = $cfname; }
          else                        { $testpath = $curremotesubdir."/".$cfname; }
          if ($testpath =~ /$ignoremask/ )
            {
              logger("","Ignoring ".$testpath." which matches ".$ignoremask."\n");
              next;
            }
        }
      if (substr($cftype,0,1) eq 'l') {  # link, rest of string = linkto
        my $curnrl;
        if ($curremotesubdir eq "") { $curnrl = $cfname; }
        else                        { $curnrl = $curremotesubdir."/".$cfname; }
        $remotelinks{$curnrl}=$cfname;
        logger("","","Link: ".$curnrl." -> ".$cfname."\n");
      }
      elsif ($cftype eq 'd') {
        if (!$doflat) {
          my $curnewrsd;
          if ($curremotesubdir eq "") { $curnewrsd = $cfname; }
          else                        { $curnewrsd = $curremotesubdir."/".$cfname; }
          $remotedirs{$curnewrsd}=$curnewrsd;
	  logger("",":","Directory: ".$curnewrsd."\n");
          push @currecursedirs, $cfname;
        }
      } elsif ($cftype eq 'f') {  #plain file
        my $curnewrf;
        if ($curremotesubdir eq "") { $curnewrf = $cfname; }
        else                        { $curnewrf = $curremotesubdir."/".$cfname; }
        #$remotefiledates{$curnewrf}=$cftime;
        $remotefiledates{$curnewrf}=$ftpc->mdtm($cfname)+$syncoff;
        if ($remotefiledates{$curnewrf} le 0) { die "Timeout detecting modification time of $curnewrf\n"; }
        $remotefilesizes{$curnewrf}=$cfsize;
        if ($remotefilesizes{$curnewrf} lt 0) { die "Timeout detecting size of $curnewrf\n"; }
        logger("",".","File: ".$curnewrf."\n");
      } else {
	  logger("Unkown file: $curlsline\n");
      }
    } else {
	logger("","","Ignoring.\n");
    }
  }
  #recurse
  #if ($doflat) { @currecursedirs=(); }
  my $currecurseddir;
  foreach $currecurseddir (@currecursedirs)
  { my $oldcurremotesubdir;
    $oldcurremotesubdir=$curremotesubdir;
    if ($curremotesubdir eq "") { $curremotesubdir = $currecurseddir; }
    else                        { $curremotesubdir .= "/".$currecurseddir; }
    my $curcwddir="";
    if ($ftpdir eq "/")
    { $curcwddir=$ftpdir.$curremotesubdir; }
    else
    { $curcwddir=$ftpdir."/".$curremotesubdir; }
    logger("","","Change dir: ".$curcwddir."\n");
    $ftpc->cwd($curcwddir)
      or die "Cannot cwd to  $curcwddir", $ftpc->message ;
    my $ftpcurdir=$ftpc->pwd();
    if ($ftpcurdir ne $curcwddir && $ftpcurdir ne "$curcwddir".'/') {
      die "Could not cwd to $curcwddir :" . $ftpc->message ; }
    buildremotetree();
    $ftpc->cdup();
    $curremotesubdir = $oldcurremotesubdir;
  }
}


sub dosync()
{
  chdir $localdir || die "Could not change to local base directory $localdir\n";
  if ($syncdirection eq "put") {
    # create dirs missing at the target
    if ($doinfoonly) { 
	print "\nWould create new remote directories.\n";
    } else {
	logger("\nCreating new remote directories.\n");
    }
    my $curlocaldir;
    foreach $curlocaldir (sort { return length($a) <=> length($b); } keys(%localdirs)) {
	if (! exists $remotedirs{$curlocaldir}) { 
	    logger("d","$curlocaldir\n");
	    if ($doinfoonly) { next; }
	    if ($ftpc->mkdir($curlocaldir) ne $curlocaldir) { die "Could not create remote subdirectory $curlocaldir\n"; }
	    $ftpc->quot('SITE', sprintf('CHMOD %04o %s', (lstat $curlocaldir)[2] & 07777, $curlocaldir));
	}
    }
    # copy files missing or too old at the target, synchronize timestamp _after_ copying
    if    ($doinfoonly) { print "\nWould copy new(er) local files.\n"; }
    else {
	logger("\nCopying new(er) local files.\n");
    }
    my $curlocalfile;
    foreach $curlocalfile (sort { return length($b) <=> length($a); } keys(%localfiledates))
    { my $dorefresh=0;
      if    (! exists $remotefiledates{$curlocalfile}) {
        $dorefresh=1;
        $infotext="New: ".$curlocalfile." (".$localfilesizes{$curlocalfile}." bytes)\n";
	logger("n",$infotext);
        if ($doinfoonly) { next; }
      }
      elsif ($notimestampcheck == 0 && $remotefiledates{$curlocalfile} < $localfiledates{$curlocalfile}) {
        $dorefresh=1;
        $infotext="Newer: ".$curlocalfile." (".$localfilesizes{$curlocalfile}." bytes, ".$localfiledates{$curlocalfile}." versus ".$remotefiledates{$curlocalfile}.")\n";
	logger("u",$infotext);
        if ($doinfoonly) { next; }
      }
      elsif ($remotefilesizes{$curlocalfile} != $localfilesizes{$curlocalfile}) {
        $dorefresh=1;
        $infotext="Changed (different sized): ".$curlocalfile." (".$localfilesizes{$curlocalfile}."  versus ".$remotefilesizes{$curlocalfile}." bytes)\n";
	logger("u",$infotext);
        if ($doinfoonly) { next; }
      }
      if (! $dorefresh) { next; }
      logger("","","Really PUTting file ".$curlocalfile."\n");
      # Some servers crash if commands are given too fast, so wait a little.
      if ($slowmillis gt 0) {
        select(undef, undef, undef, $slowmillis/1000);
      }
      if ($ftpc->put($curlocalfile, $curlocalfile) ne $curlocalfile)
      { print STDERR "Could not put localfile $curlocalfile\n"; }
      my $retries = 3;
      while ( ($ftpc->size($curlocalfile) != (lstat $curlocalfile)[7]) and ($retries-- > 0) )
      { logger("Re-Transfering $curlocalfile\n");
        if ($ftpc->put($curlocalfile, $curlocalfile) ne $curlocalfile)
        { warning("Could not re-put localfile $curlocalfile\n"); }
      }
      my $newremotemdt=$ftpc->mdtm($curlocalfile)+$syncoff;
      if ($notimestamping == 0) {
        utime ($newremotemdt, $newremotemdt, $curlocalfile);
      }
      $ftpc->quot('SITE', sprintf('CHMOD %04o %s', (lstat $curlocalfile)[2] & 07777, $curlocalfile));
    }
    if (! $nodelete)
    {
      # delete files too much at the target
      if ($doinfoonly) { print "\nWould delete obsolete remote files.\n"; }
      else {
	  logger("\nDeleting obsolete remote files.\n");
      }
      my $curremotefile;
      foreach $curremotefile (keys(%remotefiledates)) { 
	  if (not exists $localfiledates{$curremotefile}) { 
	      logger("r",$curremotefile."\n");
	      if ($doinfoonly) { next; }
	  }
          if ($ftpc->delete($curremotefile) ne 1) { die "Could not delete remote file $curremotefile\n"; }
      }
      # delete dirs too much at the target
      if    ($doinfoonly) { print "\nWould delete obsolete remote directories.\n"; }
      else {
	  logger("\nDeleting obsolete remote directories.\n");
      }
      my $curremotedir;
      foreach $curremotedir (sort { return length($b) <=> length($a); } keys(%remotedirs)) { 
	  if (! exists $localdirs{$curremotedir}) { 
	      logger("R",$curremotedir."\n");
	      if ($doinfoonly) { next; }
	      if ($ftpc->rmdir($curremotedir) ne 1) { die "Could not remove remote subdirectory $curremotedir\n"; }
	  }
      }
    } 
  } else { # $syncdirection eq "GET"
    # create dirs missing at the target
    if ($doinfoonly) { 
	logger("\nWould create new local directories.\n");
    } else {
	logger("\nCreating new local directories.\n");
    }
    my $curremotedir;
    foreach $curremotedir (sort { return length($a) <=> length($b); } keys(%remotedirs)) { 
	if (! exists $localdirs{$curremotedir}) {
	    logger("d",$curremotedir."\n");
	    if ($doinfoonly) { print ; next; }
    	}
        mkdir($curremotedir) || die "Could not create local subdirectory $curremotedir\n";
    }
    # copy files missing or too old at the target, synchronize timestamp _after_ copying
    if ($doinfoonly) { 
	logger("\nWould copy new(er) remote files.\n");
    } else {
	logger("\nCopying new(er) remote files.\n");
    }
    my $curremotefile;
    foreach $curremotefile (sort { return length($b) <=> length($a); } keys(%remotefiledates))
    { my $dorefresh=0;
      if    (! exists $localfiledates{$curremotefile}) {
        $dorefresh=1;
        $infotext="New: ".$curremotefile." (".$remotefilesizes{$curremotefile}." bytes)\n";
	logger("n",$infotext);
        if ($doinfoonly) { next; }
      }
      elsif ($notimestampcheck == 0 && $remotefiledates{$curremotefile} > $localfiledates{$curremotefile}) {
        $dorefresh=1;
        $infotext="Newer: ".$curremotefile." (".$remotefilesizes{$curremotefile}." bytes, ".$remotefiledates{$curremotefile}." versus ".$localfiledates{$curremotefile}.")\n";
	logger("u",$infotext);
        if ($doinfoonly) { next; }
      }
      elsif ($remotefilesizes{$curremotefile} != $localfilesizes{$curremotefile}) {
        $dorefresh=1;
        $infotext="Changed (different sized): ".$curremotefile." (".$remotefilesizes{$curremotefile}." bytes)\n";
	logger("u",$infotext);
        if ($doinfoonly) { next; }
      }
      if (! $dorefresh) { next; }
      logger("Really GETting file ".$curremotefile."\n");
      my $rc=$ftpc->get($curremotefile, $curremotefile);
      if ( ($rc eq undef) or ($rc ne $curremotefile) )
      { print STDERR "Could not get file ".$curremotefile."\n"; }
      my $retries=3;
      while ( ($ftpc->size($curremotefile) != (lstat $curremotefile)[7]) and ($retries-- > 0) )
      { 
	  logger("Re-Transfering $curremotefile\n");
        if ( ($rc eq undef) or ($rc ne $curremotefile) )
        { print STDERR "Could not get file ".$curremotefile."\n"; }
      }
      my $newlocalmdt=$remotefiledates{$curremotefile};
      if ($notimestamping == 0) {
        utime ($newlocalmdt, $newlocalmdt, $curremotefile);
      }
    }
    if (! $nodelete)
    {
      # delete files too much at the target
      if    ($doinfoonly) { print "\nWould delete obsolete local files.\n"; }
      else {
	  logger("\nDeleting obsolete local files.\n");
      }
      my $curlocalfile;
      foreach $curlocalfile (sort { return length($b) <=> length($a); } keys(%localfiledates))
      { if (not exists $remotefiledates{$curlocalfile})
        { 
	  logger("r",$curlocalfile."\n");

          if (unlink($curlocalfile) ne 1) { die "Could not remove local file $curlocalfile\n"; }
        }
      }
      # delete dirs too much at the target
      if    ($doinfoonly) { logger("\nWould delete obsolete local directories.\n"); }
      else {
	  logger("\nDeleting obsolete local directories.\n");
      }
      my $curlocaldir;
      foreach $curlocaldir (keys(%localdirs))
      { if (! exists $remotedirs{$curlocaldir})
        { 
	    logger("d",$curlocaldir."\n");
	    if ($doinfoonly) { next; }
	    rmdir($curlocaldir) || die "Could not remove local subdirectory $curlocaldir\n";
        }
      }
    }
  }
}

sub parse_remote_url() {
    if ($remoteURL =~ /^ftp:\/\/(([^@\/\\\:]+)(:([^@\/\\\:]+))?@)?([a-zA-Z01-9\.\-]+)(\/(.*))?/) {
	#print "DEBUG: parsing ".$remoteURL."\n";
	#print "match 1 = ".$1."\n";
	#print "match 2 = ".$2."\n";
	#print "match 3 = ".$3."\n";
	#print "match 4 = ".$4."\n";
	#print "match 5 = ".$5."\n";
	#print "match 6 = ".$6."\n";
	#print "match 7 = ".$7."\n";
	if (length($2) > 0) { $ftpuser=$2; }
	if (length($4) > 0) { $ftppasswd=$4; }
	$ftpserver=$5;
	$ftpdir=$7;
	if ($ftpdir ne "/") { $ftpdir=~s/\/$//; }
    }
}


sub print_syntax() {
  print "\n";
  print "ftpsync 1.3.07 (2012-01-28)\n";
  print "\n";
  print " ftpsync [ options ] [ localdir remoteURL ]\n";
  print " ftpsync [ options ] [ remoteURL localdir ]\n";
  print " options = [-dfgpqv] [ cfg|ftpuser|ftppasswd|ftpserver|ftpdir=value ... ] \n";
  print "   localdir    local directory, defaults to \".\".\n";
  print "   ftpURL      full FTP URL, scheme\n";
  print '               ftp://[ftpuser[:ftppasswd]@]ftpserver/ftpdir'."\n";
  print "               ftpdir is relative, so double / for absolute paths as well as /\n";
  print "   -c | -C     like -i, but then prompts whether to actually do work\n";
  print "   -d | -D     turns debug output (including verbose output) on\n";
  print "   -f | -F     flat operation, no subdir recursion\n";
  print "   -g | -G     forces sync direction to GET (remote to local)\n";
  print "   -h | -H     prints out this help text\n";
  print "   -i | -I     forces info mode, only telling what would be done\n";
  print "   -n | -N     no deletion of obsolete files or directories\n";
  print "   -l | -L     follow local symbolic links as if they were directories\n";
  print "   -p | -P     forces sync direction to PUT (local to remote)\n";
  print "   -q | -Q     turns quiet operation on\n";
  print "   -s | -S     turns timestamp comparison off (only checks for changes in size)\n";
  print "   -t | -T     turns timestamp setting for local files off\n"; # backward compatibility
  print "   -v | -V     turnes verbose output on\n";
  print "   cfg=        read parameters and options from file defined by value.\n";
  print "   ftpserver=  defines the FTP server, defaults to \"localhost\".\n";
  print "   ftpdir=     defines the FTP directory, defaults to \".\" (/wo '\"') \n";
  print "   ftpuser=    defines the FTP user, defaults to \"ftp\".\n";
  print "   ftppasswd=  defines the FTP password, defaults to \"anonymous\".\n";
  print "   ignoremask= defines a regexp to ignore certain files, like .svn"."\n";
  print "   slowmillis= sleeps speficed # of ms between PUTs, default 100, 0=off"."\n";
  print "   timeoffset= overrules clocksync() detection with given offset in seconds"."\n";
  print "\n";
  print " Later mentioned options and parameters overwrite those mentioned earlier.\n";
  print " Command line options and parameters overwrite those in the config file.\n";
  print " Don't use '\"', although mentioned default values might motiviate you to.\n";
  print "\n";
  print " If ftpuser or ftppasswd resovle to ? (no matter through which options),\n";
  print " ftpsync.pl asks you for those interactively.\n";
  print "\n";
  print " As of 1.3.02 .netrc is used if ftppassword or ftppassword and ftpuser)\n";
  print " are still empty after parsing all options.\n";
  print "\n";
}


sub print_options() {
  print "\nPrinting options:\n";
  # meta
  print "returncode    = ", $returncode    , "\n";
  print "configfile    = ", $configfile    , "\n";
  # basiscs
  print "syncdirection = ", $syncdirection , "\n";
  print "localdir      = ", $localdir      , "\n";
  # FTP stuff
  print "remoteURL     = ", $remoteURL     , "\n";
  print "ftpuser       = ", $ftpuser       , "\n";
  print "ftppasswd     = ", $ftppasswd     , "\n";
  print "ftpserver     = ", $ftpserver     , "\n";
  print "ftpdir        = ", $ftpdir        , "\n";
  # verbosity
  print "doverbose     = ", $doverbose     , "\n";
  print "dodebug       = ", $dodebug       , "\n";
  print "doquiet       = ", $doquiet       , "\n";
  # other
  print "doinfoonly    = ", $doinfoonly    , "\n";
  print "slowmillis    = ", $slowmillis    , "\n";
  print "\n";
}


sub logger {
    # Print out information
    # logger("Info_string","Verbose_string","Debug_string")
    # Verbose_string defaults to Info_string
    # Debug_string defaults to Verbose_string
    #
    # $opt::verbose = 0  => quiet
    # $opt::verbose = 1  => info
    # $opt::verbose = 2  => verbose
    # $opt::verbose = 3  => debug
    # $opt::verbose = 4  => debug with ftp communication
    my @w = ("",@_);
    # Verbose_string defaults to Info_string
    $w[2] ||= $w[1];
    # Debug_string defaults to Verbose_string
    $w[3] ||= $w[2];
    # Debug_string defaults to Verbose_string
    $w[4] ||= $w[3];
    # FTP Debug_string defaults to Debug_string
    $w[5] ||= $w[4];
    print $w[$opt::verbose];
}


sub warning {
    my @w = @_;
    my $prog = $Global::progname || "ftpsync";
    print STDERR $prog, ": Warning: ", @w;
}


sub error {
    my @w = @_;
    my $prog = $Global::progname || "ftpsync";
    print STDERR $prog, ": Error: ", @w;
    exit(1);
}

sub usleep {
    # Sleep this many milliseconds.
    my $secs = shift;
    select(undef, undef, undef, $secs/1000);
}

sub my_dump {
    # Returns:
    #   ascii expression of object if Data::Dump(er) is installed
    #   error code otherwise
    my @dump_this = (@_);
    eval "use Data::Dump qw(dump);";
    if ($@) {
        # Data::Dump not installed
        eval "use Data::Dumper;";
        if ($@) {
            my $err =  "Neither Data::Dump nor Data::Dumper is installed\n".
                "Not dumping output\n";
            print $Global::original_stderr $err;
            return $err;
        } else {
            return Dumper(@dump_this);
        }
    } else {
	# Create a dummy Data::Dump:dump as Hans Schou sometimes has
	# it undefined
	eval "sub Data::Dump:dump {}";
        eval "use Data::Dump qw(dump);";
        return (Data::Dump::dump(@dump_this));
    }
}

